
<html>
<head>
  <style>
   body {
  background-color: lightblue;
  font-family: Arial;
}

h1 {
  color: white;
  text-align: center;
  text-shadow: 2px 2px 4px black; /* Add a shadow effect to the title */
}

table {
  border-collapse: collapse;
  margin-left: auto;
  margin-right: auto;
}

td {
  border: 3px solid black;
  width: 100px;
  height: 100px;
  font-size: 72px;
  text-align: center;

/* Add a gradient background for the cells */
background-image: linear-gradient(to bottom right, lightgreen, lightpink);


body {
  background-color: lightblue;
  font-family: Arial;
}


h1 {
  color: white;
  text-align: center;
  text-shadow: 2px 2px 4px black; /* Add a shadow effect to the title */
}

table {
  border-collapse: collapse;
  margin-left: auto;
  margin-right: auto;
}

td {
  border: 3px solid black;
  width: 100px;
  height: 100px;
  font-size: 72px;
  text-align: center;

/* Add a gradient background for the cells */
background-image: linear-gradient(to bottom right, lightgreen, lightpink);

/* Add a hover effect for the cells */
:hover {
    transform: scale(1.1); /* Make the cell slightly bigger when hovered */
    box-shadow: inset -5px -5px 10px rgba(0,0,0,0.2); /* Add an inner shadow effect when hovered */
}
}
footer {
    background-color: #555;
    color: white;

    padding: 15px;
    text-align: center;
    font-size: 12px;
    position: fixed;
    left: 0;
    bottom: 0;
    width: 100%;
}
body {
  background-color: lightblue;
  font-family: Arial;
}

h1 {
  color: white;
  text-align: center;
  text-shadow: 2px 2px 4px black; /* Add a shadow effect to the title */
}

table {
  border-collapse: collapse;
  margin-left: auto;
  margin-right: auto;
}

td {
  border: 3px solid black;
  width: 100px;
  height: 100px;
  font-size: 72px;
  text-align: center;

/* Add a gradient background for the cells */
background-image: linear-gradient(to bottom right, lightgreen, lightpink);

/* Add a hover effect for the cells */
:hover {
    transform: scale(1.1); /* Make the cell slightly bigger when hovered */
    box-shadow: inset -5px -5px 10px rgba(0,0,0,0.2); /* Add an inner shadow effect when hovered */

/*style p and footer*/
p {
    font-size: 20px;
    color: white;
    text-align: center;
    text-shadow: 2px 2px 4px black;
}

footer {
    background-color: #555;
    color: white;

    padding: 15px;
    text-align: center;
    font-size: 12px;
    position: fixed;
    left: 0;
    bottom: 0;
    width: 100%;
}




  </style>
</head>
<body>
  <h1>Let's play tic-tac-toe</h1>
  <p>You are X and I am O. You go first. Click on an empty cell to make your move.</p>
  <table id="board">
    <tr>
      <td id="cell_0" onclick="userMove(0)"></td>
      <td id="cell_1" onclick="userMove(1)"></td>
      <td id="cell_2" onclick="userMove(2)"></td>
    </tr>
    <tr>
      <td id="cell_3" onclick="userMove(3)"></td>
      <td id="cell_4" onclick="userMove(4)"></td>
      <td id="cell_5" onclick="userMove(5)"></td>
    </tr>
    <tr>
      <td id="cell_6" onclick="userMove(6)"></td>
      <td id="cell_7" onclick="userMove(7)"></td>
      <td id="cell_8" onclick="userMove(8)"></td> 
    </tr>  
  </table>

  
    <footer>
        <p>Created by‚ù§üòä Raghuraj</p>
    </footer>




<script>

// Initialize the board as an array of nine empty strings
var board = ["", "", "", "", "", "", "", "", ""];

// Define the winning combinations as an array of arrays
var winCombos = [
  [0, 1, 2],
  [3, 4, 5],
  [6, 7, 8],
  [0, 3, 6],
  [1, 4, 7],
  [2, 5 ,8],
 [0 ,4 ,8],
 [2 ,4 ,6]
];

// Define a function to check if the board is full
function isFull(board) {
 for (var i =0; i<board.length; i++) {
   if (board[i] == "") {
     return false; // If there is an empty cell, return false
   }
 }
 return true; // If there are no empty cells, return true
}

// Define a function to check if a player has won
function hasWon(board, player) {
 for (var i=0; i<winCombos.length; i++) {
   var combo = winCombos[i]; // Get one of the winning combinations
   var count =0; // Initialize a counter for how many cells match the player's symbol
   for (var j=0; j<combo.length; j++) {
     var cell = combo[j]; // Get one of the cells in the combination
     if (board[cell] == player) { // If the cell matches the player's symbol,
       count++; // Increment the counter
     }
   }
   if (count ==3) { // If all three cells match the player's symbol,
     return true; // Return true
   }
 }
 return false; // If none of the combinations match the player's symbol,
}

// Define a function to handle user's move
function userMove(index) {

 var cell = document.getElementById("cell_" + index); // Get the HTML element of the clicked cell

 if (board[index] != "") { // If the cell is not empty,
   alert("This cell is already taken. Please choose another one."); // Show an alert message
 } else { 
   board[index] = "X"; // Update the board array with user's symbol X 
   cell.innerHTML = "X"; // Update the HTML element with user's symbol X

   if (hasWon(board,"X")) { // If user has won,
     alert("You win!"); // Show an alert message 
     resetBoard(); // Reset the board for a new game
    } else if (isFull(board)) { // If the board is full,
        alert("It's a tie!"); // Show an alert message
        resetBoard(); // Reset the board for a new game
    } else { // If the game is not over,
        computerMove(); // Call the computerMove function
        }
    }
}

// Define a function to handle computer's move
function computerMove() {
  var index = Math.floor(Math.random() * 9); // Generate a random number between 0 and 8
  var cell = document.getElementById("cell_" + index); // Get the HTML element of the cell

  if (board[index] != "") { // If the cell is not empty,
    computerMove(); // Call the computerMove function again
  } else { 
    board[index] = "O"; // Update the board array with computer's symbol O
    cell.innerHTML = "O"; // Update the HTML element with computer's symbol O

    if (hasWon(board,"O")) { // If computer has won,
      alert("I win!"); // Show an alert message
      resetBoard(); // Reset the board for a new game
    } else if (isFull(board)) { // If the board is full,
      alert("It's a tie!"); // Show an alert message
      resetBoard(); // Reset the board for a new game
    }
  }
}
// Define a function to evaluate the board state and return a score
function evaluate(board) {
  // Check for horizontal win
  for (var i = 0; i < 3; i++) {
    if (board[i * 3] == board[i * 3 + 1] && board[i * 3 + 1] == board[i * 3 + 2]) {
      if (board[i * 3] == "O") return +10; // Computer wins
      if (board[i * 3] == "X") return -10; // Human wins
    }
  }

  // Check for vertical win
  for (var i = 0; i < 3; i++) {
    if (board[i] == board[i + 3] && board[i + 3] == board[i + 6]) {
      if (board[i] == "O") return +10; // Computer wins
      if (board[i] == "X") return -10; // Human wins
    }
  }

   // Check for diagonal win
   if (board[0] == board[4] && board[4] == board[8]) {
     if (board[0] == "O") return +10; // Computer wins
     if (board[0] == "X") return -10; // Human wins
   }

   if (board[2] == board[4] && board[4] == board[6]) {
     if (board[2] == "O") return +10; // Computer wins
     if (board[2] == "X") return -10; // Human wins
   }

   // No one wins
   return 0;
}

// Define a function to find the best move for the computer using minimax algorithm
function bestMove(board) {
  
 var bestScore = -Infinity; // Initialize the best score as negative infinity 
 var bestIndex = -1; // Initialize the best index as -1

 for (var i = 0; i < board.length; i++) { // Loop through all cells in the board
   
   if (board[i] == "") { // If the cell is empty,
     
     board[i]= "O"; // Make a temporary move with computer's symbol O
     
     var score = minimax(board,false); // Call the minimax function with human's turn
     
     board[i]= ""; // Undo the temporary move
     
     if(score > bestScore) { 
       bestScore = score;
       bestIndex = i;
     }
     
   }
   
 }
 
 return bestIndex;
}

// Define a function to implement the minimax algorithm recursively 
function minimax(board,isMaximizing) {

 var score = evaluate(board); 

if(score==10 || score==-10 || isFull(board)) { 
return score;
}

if(isMaximizing) { 

var bestScore= -Infinity;

for(var i=0;i<board.length;i++) {

if(board[i]=="") {

board[i]="O";

var score=minimax(board,false);

bestScore=Math.max(bestScore,score);

board[i]="";

}

}

return bestScore;

} else {

var bestScore= Infinity;

for(var i=0;i<board.length;i++) {

if(board[i]=="") {

board[i]="X";

var score=minimax(board,true);

bestScore=Math.min(bestScore,score);

board[i]="";

}

}

return bestScore;

}
}// Define a function to handle computer's move using minimax algorithm

function computerMove() {

 var index = bestMove(board); 

 var cell = document.getElementById("cell_" + index); 

 board[index]= "O"; 

 cell.innerHTML="O"; 

if(hasWon(board,"O")) { 

alert("I win!"); 

resetBoard(); 

} else if(isFull(board)) { 

alert("It's a tie!"); 

resetBoard(); 

}
}
// Define a function to reset the board
function resetBoard() {
  board = ["", "", "", "", "", "", "", "", ""]; // Reset the board array
  for (var i=0; i<9; i++) { // Loop through all the cells
    var cell = document.getElementById("cell_" + i); // Get the HTML element of the cell
    cell.innerHTML = ""; // Reset the HTML element
  }
}



</script>
</body>
</html>
